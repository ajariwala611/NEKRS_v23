!-----------------------------------------------------------------------
!  nek5000 user-file template
!
!  user specified routines:
!     - uservp  : variable properties
!     - userf   : local acceleration term for fluid
!     - userq   : local source term for scalars
!     - userbc  : boundary conditions
!     - useric  : initial conditions
!     - userchk : general purpose routine for checking errors etc.
!     - userqtl : thermal divergence for lowMach number flows 
!     - usrdat  : modify element vertices 
!     - usrdat2 : modify mesh coordinates
!     - usrdat3 : general purpose routine for initialization
!     
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
      subroutine uservp(ix,iy,iz,eg) ! set variable properties

!      implicit none

      integer ix,iy,iz,eg
     
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      integer e
!     e = gllel(eg)

      udiff  = 0.0
      utrans = 0.0

      return
      end
!-----------------------------------------------------------------------
      subroutine userf(ix,iy,iz,eg) ! set acceleration term
!
!         Note: this is an acceleration term, NOT a force!
!         Thus, ffx will subsequently be multiplied by rho(x,t).
!
!         Note: This function will be used to implemend immersed boundary forces.
!         Assumes constant rho = 1
!
!         Modified by Alex Tsolovikos on 2022-01-12
!
          implicit none

          integer ix,iy,iz,eg
          real pgain, igain

          include 'SIZE'
          include 'TOTAL'
          include 'NEKUSE'

          integer e
          e = gllel(eg)


          ffx = 0.0
          ffy = 0.0
          ffz = 0.0

          return
      end
!-----------------------------------------------------------------------
      subroutine userq(ix,iy,iz,eg) ! set source term

!          implicit none

          integer ix,iy,iz,eg

          include 'SIZE'
          include 'TOTAL'
          include 'NEKUSE'

          integer e
!         e = gllel(eg)

          qvol   = 0.0

          return
      end
!-----------------------------------------------------------------------
      subroutine userbc(ix,iy,iz,iside,eg) ! set up boundary conditions
!
!         NOTE ::: This subroutine MAY NOT be called by every process
!
!         The boundary conditions are:
!             1) Blasius boundary layer at the inlet
!             2) Convective BC at the outlet
!             3) No-slip BC at the wall (y=0)
!             4) v = V_Blasius, du/dy = dv/dx, dw/dy = dv/dz
!                (zero vorticity) at the top (y=1)
!             5) Periodic BC at the sides (z=0, z=1)
!         NOTE ::: Only BCs 1) and 4) are implemented here. The others are 
!                  implemented by the mesh.
!         
          implicit none

          integer ix,iy,iz,iside,eg,e
          real xp

          include 'SIZE'
          include 'TOTAL'
          include 'NEKUSE'

          real ub(lx1,ly1,lz1,lelt), vb(lx1,ly1,lz1,lelt)
          common /blasiusvel/ ub, vb


            e = gllel(eg)
            xp = xm1(ix,iy,iz,e)

            if (cbu .eq. 'v  ') then
                  call RPI_inflow_bc(ux,uy,uz,ix,iy,iz,e)
                  temp = 0.0
            else if (cbu .eq. 'o  ') then
			pa = 0.0
            end if

          return
      end
!-----------------------------------------------------------------------
      subroutine useric(ix,iy,iz,eg) ! set up initial conditions
!
!         Set the Blasius solution everywhere.
!         Modified by Alex Tsolovikos on 2022-01-11
!
          implicit none

          integer ix,iy,iz,eg,e

          include 'SIZE'
          include 'TOTAL'
          include 'NEKUSE'

          real ub(lx1,ly1,lz1,lelt), vb(lx1,ly1,lz1,lelt)
          common /blasiusvel/ ub, vb

          e = gllel(eg)
          ux   = ub(ix,iy,iz,e)
          uy   = vb(ix,iy,iz,e)
          uz   = 0.0
          temp = 0.0

          return
      end
!-----------------------------------------------------------------------
      subroutine userchk
          include 'SIZE'
          include 'TOTAL'

          return
      end
!-----------------------------------------------------------------------
      subroutine userqtl ! Set thermal divergence

      call userqtl_scig 

      return
      end
!-----------------------------------------------------------------------
      subroutine usrdat()   ! This routine to modify element vertices

!      implicit none

      include 'SIZE'
      include 'TOTAL'

       integer n
       real ymin, ymax
       real           xstart, U_inf, BETAM, dt_rpi
       COMMON /CASEDATA/ xstart, U_inf, BETAM, dt_rpi

        ! Modify y-coordinate of elements
       n = nelv * 2**ldim
       ymin = glmin(yc,n)
       ymax = glmax(yc,n)

       do i = 1,n
           yc(i,1) = ymin + (ymax - ymin) * (tanh( BETAM * (yc(i,1)/(ymax-ymin)-1)) / tanh(BETAM) + 1)
       end do
 
      return
      end
!-----------------------------------------------------------------------
      subroutine usrdat2()  ! This routine to modify mesh coordinates

!         implicit none

          include 'SIZE'
          include 'TOTAL'

          ! reconstruct boundary tags 

          return
      end
!-----------------------------------------------------------------------
      subroutine usrdat3()

          implicit none

          include 'SIZE'
          include 'TOTAL'

        !   real ub(lx1,ly1,lz1,lelt), vb(lx1,ly1,lz1,lelt)
        !   common /blasiusvel/ ub, vb

        !   ! Set blasius velocity profile
        !   call set_blasius(ub, vb)
          call set_rpi_inflow()

          return
      end
!-----------------------------------------------------------------------
      subroutine usrdat0()
        include 'SIZE'
        include 'TOTAL'
  
        real           xstart, U_inf, BETAM, dt_rpi
        COMMON /CASEDATA/ xstart, U_inf, BETAM, dt_rpi
  
        COMMON /NRSSCPTR/ nrs_scptr(4)
        integer*8         nrs_scptr
  
        nrs_scptr(1) = loc(xstart)
        nrs_scptr(2) = loc(U_inf)
        nrs_scptr(3) = loc(BETAM)
        nrs_scptr(4) = loc(dt_rpi)
  
        return
        end
!-----------------------------------------------------------------------
      subroutine set_blasius(ub,vb)
          
          implicit none

          include 'SIZE'
          include 'TOTAL'


          integer n, i
          real ub(lx1,ly1,lz1,lelt), vb(lx1,ly1,lz1,lelt)
          real nu
          real xp, yp, eta_tmp, f_tmp, fp_tmp, Rex

          real           xstart, U_inf, BETAM, dt_rpi
          COMMON /CASEDATA/ xstart, U_inf, BETAM, dt_rpi

          real eta(10001), f(10001), fp(10001)

          ! 1. Solve the Falknerâ€“Skan equation.
          call solve_blasius(eta, f, fp)

          ! 2. Iterate through all points and compute Blasius velocity
          !    from the presolved FS equation. For locations not in eta,
          !    do linear interpolation.

          n = nx1*ny1*nz1*nelv

          nu = param(2) / param(1) ! Kinematic viscosity

          do i = 1, n
              xp = xm1(i,1,1,1) + xstart
              yp = ym1(i,1,1,1)
              Rex = U_inf * xp / nu

              eta_tmp = yp / xp * sqrt(Rex)
              call pwl_value_1d(10001,eta,f,1,eta_tmp,f_tmp)
              call pwl_value_1d(10001,eta,fp,1,eta_tmp,fp_tmp)

              ub(i,1,1,1) = U_inf * fp_tmp
              vb(i,1,1,1) = U_inf * (eta_tmp * fp_tmp - f_tmp)/(2.0 * sqrt(Rex))
          end do

          return
      end
!-----------------------------------------------------------------------
      subroutine solve_blasius(eta,f,fp)
          
          implicit none

          include 'SIZE'
          include 'TOTAL'

          real, intent(out) :: eta(10001), f(10001), fp(10001)
          real, parameter :: deta = 1.e-6
          real f_tmp, fp_tmp, fpp_tmp, fppp_tmp, eta_tmp
          integer i

          f_tmp = 0
          fp_tmp = 0
          fpp_tmp = 0.332
          fppp_tmp = 0
          eta_tmp = 0
          i = 1

          do while (eta_tmp <= 10.0)
              fpp_tmp = fpp_tmp + deta * fppp_tmp
              fp_tmp = fp_tmp + deta * fpp_tmp
              f_tmp = f_tmp + deta * fp_tmp
              fppp_tmp = -0.5 * f_tmp * fpp_tmp

              if (mod(i-1,1000) == 0) then
                  eta(i/1000+1) = eta_tmp
                  f(i/1000+1) = f_tmp
                  fp(i/1000+1) = fp_tmp
              end if

              i = i + 1
              eta_tmp = eta_tmp + deta
          end do

          return
      end
!-----------------------------------------------------------------------
      subroutine set_rpi_inflow

            implicit none

            include 'SIZE'
            include 'TOTAL'

            integer i, j, ie, ix, iy, iz
            real xp, yp, zp, xmin

            real, allocatable :: a(:,:)
            
            integer, parameter :: n_y = 40, n_z = 146, n_f = 72
            real inflow_prof_u(n_z,n_y,n_f), inflow_prof_v(n_z,n_y,n_f), inflow_prof_w(n_z,n_y,n_f)
            real y_dist(n_y), z_dist(n_z)
            common /rpi_inflow/ inflow_prof_u, inflow_prof_v, inflow_prof_w, y_dist, z_dist

            allocate(a(n_z*n_f,n_y))
            ! Read y and z grid
            open(21, file='rpi_grid_y.dat',status='old',action='read')
            do i = 1,n_y
            read(21,*)y_dist(i)
            end do
            close(21)

            open(22, file='rpi_grid_z.dat',status='old',action='read')
            do i = 1,n_z
            read(22,*)z_dist(i)
            end do
            close(22)
    

            ! Read U(nz,ny),V(nz,ny), and W(nz,ny) velocities		  
            open(23, file='inflow_prof_U.dat',status='old',action='read')
            j = 1
            do i = 1,n_z*n_f
            read(23,*)a(i,:)
            if (mod(i,n_z) == 0 ) then
                  inflow_prof_u(:,:,j) = a((j-1)*n_z+1:j*n_z,:)
                  j = j+1
            end if
            end do
            close(23)
            
            open(24, file='inflow_prof_V.dat',status='old',action='read')
            j = 1
            do i = 1,n_z*n_f
            read(24,*)a(i,:)
            if (mod(i,n_z) == 0 ) then
                  inflow_prof_v(:,:,j) = a((j-1)*n_z+1:j*n_z,:)
                  j = j+1
            end if
            end do
            close(24)
            
            open(25, file='inflow_prof_W.dat',status='old',action='read')
            j = 1
            do i = 1,n_z*n_f
            read(25,*)a(i,:)
            if (mod(i,n_z) == 0 ) then
                  inflow_prof_w(:,:,j) = a((j-1)*n_z+1:j*n_z,:)
                  j = j+1
            end if
            end do
            close(25)

            return
      end    
!-----------------------------------------------------------------------
      subroutine RPI_inflow_bc(ux,uy,uz,ix,iy,iz,e)
      !1D linear time interpolation subroutine for RPI data
      !Akshit 11/05/2022

            implicit none	

            include 'SIZE'
            include 'TOTAL'

            real ux, uy, uz	
            real dt_rpi
            integer ix, iy, iz, e, n1
            integer cycle, counter

            real ub(lx1,ly1,lz1,lelt), vb(lx1,ly1,lz1,lelt)
            common /blasiusvel/ ub, vb

            integer, parameter :: n_y = 40, n_z = 146, n_f = 72
            real inflow_prof_u(n_z,n_y,n_f), inflow_prof_v(n_z,n_y,n_f), inflow_prof_w(n_z,n_y,n_f)
            real y_dist(n_y), z_dist(n_z)
            common /rpi_inflow/ inflow_prof_u, inflow_prof_v, inflow_prof_w, y_dist, z_dist
            
            real prof_u(n_z,n_y), prof_v(n_z,n_y), prof_w(n_z,n_y)
            
            dt_rpi = uparam(3)
            counter = floor(time/dt_rpi)
            n1 = mod(counter,n_f) !Frame number
            cycle = floor(time/dt_rpi/n_f) !Cycle number
            if (cycle .eq. 0) then
                  if (n1 .eq. 0) then
                        prof_u = inflow_prof_u(:,:,1)
                        prof_v = inflow_prof_v(:,:,1)
                        prof_w = inflow_prof_w(:,:,1)

                        call interp_2d_rpi_data(n_z, n_y, z_dist, y_dist, prof_u, 1, zm1(ix,iy,iz,e), ym1(ix,iy,iz,e), ux)
                        call interp_2d_rpi_data(n_z, n_y, z_dist, y_dist, prof_v, 1, zm1(ix,iy,iz,e), ym1(ix,iy,iz,e), uy)
                        call interp_2d_rpi_data(n_z, n_y, z_dist, y_dist, prof_w, 1, zm1(ix,iy,iz,e), ym1(ix,iy,iz,e), uz)
                        
                        ux = (ub(ix,iy,iz,e)*(dt_rpi-time) + ux*(time))/dt_rpi
                        uy = (vb(ix,iy,iz,e)*(dt_rpi-time) + uy*(time))/dt_rpi
                        uz =  uz*time/dt_rpi
                        return 
                  endif
            endif            
            if (cycle .gt. 0) then
            if (n1 .eq. 0) then
                  prof_u = (inflow_prof_u(:,:,n_f)*((counter+1)*dt_rpi-time) + inflow_prof_u(:,:,1)*(time-counter*dt_rpi))/dt_rpi
                  prof_v = (inflow_prof_v(:,:,n_f)*((counter+1)*dt_rpi-time) + inflow_prof_v(:,:,1)*(time-counter*dt_rpi))/dt_rpi
                  prof_w = (inflow_prof_w(:,:,n_f)*((counter+1)*dt_rpi-time) + inflow_prof_w(:,:,1)*(time-counter*dt_rpi))/dt_rpi

                  call interp_2d_rpi_data(n_z, n_y, z_dist, y_dist, prof_u, 1, zm1(ix,iy,iz,e), ym1(ix,iy,iz,e), ux)
                  call interp_2d_rpi_data(n_z, n_y, z_dist, y_dist, prof_v, 1, zm1(ix,iy,iz,e), ym1(ix,iy,iz,e), uy)
                  call interp_2d_rpi_data(n_z, n_y, z_dist, y_dist, prof_w, 1, zm1(ix,iy,iz,e), ym1(ix,iy,iz,e), uz)
                  return
            endif
            endif

            prof_u = (inflow_prof_u(:,:,n1)*((counter+1)*dt_rpi-time) + inflow_prof_u(:,:,n1+1)*(time-counter*dt_rpi))/dt_rpi
            prof_v = (inflow_prof_v(:,:,n1)*((counter+1)*dt_rpi-time) + inflow_prof_v(:,:,n1+1)*(time-counter*dt_rpi))/dt_rpi
            prof_w = (inflow_prof_w(:,:,n1)*((counter+1)*dt_rpi-time) + inflow_prof_w(:,:,n1+1)*(time-counter*dt_rpi))/dt_rpi

            call interp_2d_rpi_data(n_z, n_y, z_dist, y_dist, prof_u, 1, zm1(ix,iy,iz,e), ym1(ix,iy,iz,e), ux)
            call interp_2d_rpi_data(n_z, n_y, z_dist, y_dist, prof_v, 1, zm1(ix,iy,iz,e), ym1(ix,iy,iz,e), uy)
            call interp_2d_rpi_data(n_z, n_y, z_dist, y_dist, prof_w, 1, zm1(ix,iy,iz,e), ym1(ix,iy,iz,e), uz)

      return
      end 
!--------------------------------------------------------------------
      subroutine interp_2d_rpi_data(nx,ny,xd,yd,zd,nq,xq,yq,zq)
            !2D bilinear subroutine for RPI data
            !Akshit 11/05/2022
            implicit none
            
            integer i, j	
            integer nx, ny, nq
            real xd(nx), yd(ny), zd(nx,ny)
            real xq, yq, zq
            real q11, q12, q21, q22
            real f1, f2

            do i = 1,nx
                  if (xq .ge. xd(i) .and. xq .le. xd(i+1)) then
                        if (yq .lt. yd(1)) then
                        q12 = zd(i,1)
                        q22 = zd(i+1,1)
                        f2 = ((xd(i+1)-xq)*q12 + (xq-xd(i))*q22)/(xd(i+1)-xd(i)) 
                        zq = (yq*f2)/(yd(1))
                        return
                        else
                        do j = 1,ny
                              if (yq .ge. yd(j) .and. yq .le. yd(j+1)) then
                                    q11 = zd(i,j)
                                    q21 = zd(i+1,j)
                                    q12 = zd(i,j+1)
                                    q22 = zd(i+1,j+1)
                                    f1 = ((xd(i+1)-xq)*q11 + (xq-xd(i))*q21)/(xd(i+1)-xd(i)) 
                                    f2 = ((xd(i+1)-xq)*q12 + (xq-xd(i))*q22)/(xd(i+1)-xd(i)) 
                                    zq = ((yd(j+1)-yq)*f1 + (yq-yd(j))*f2)/(yd(j+1)-yd(j))
                                    return
                              end if
                        end do
                        end if
                  end if
            end do
      end 
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
      subroutine pwl_value_1d(nd,xd,yd,ni,xi,yi)
      !
      !! PWL_VALUE_1D evaluates the piecewise linear interpolant.
      !
      !  Discussion:
      !
      !    The piecewise linear interpolant L(ND,XD,YD)(X) is the piecewise
      !    linear function which interpolates the data (XD(I),YD(I)) for I = 1
      !    to ND.
      !
      !  Licensing:
      !
      !    This code is distributed under the GNU LGPL license.
      !
      !  Modified:
      !
      !    22 September 2012
      !
      !  Author:
      !
      !    John Burkardt
      !
      !  Parameters:
      !
      !    Input, integer ND, the number of data points.
      !    ND must be at least 1.
      !    Input, real ( kind = rk ) XD(ND), the data points.
      !    Input, real ( kind = rk ) YD(ND), the data values.
      !    Input, integer NI, the number of interpolation points.
      !    Input, real ( kind = rk ) XI(NI), the interpolation points.
      !    Output, real ( kind = rk ) YI(NI), the interpolated values.
      !
            implicit none
            
            integer, parameter :: rk = kind (1.0D+00)
            
            integer nd
            integer ni
            
            integer i
            integer k
            real (kind = rk) t
            real (kind = rk) xd(nd)
            real (kind = rk) yd(nd)
            real (kind = rk) xi(ni)
            real (kind = rk) yi(ni)
            
            yi(1:ni) = 0.0D+00
            
            if ( nd == 1 ) then
                  yi(1:ni) = yd(1)
                  return
            end if
            
            do i = 1, ni
                  if ( xi(i) <= xd(1) ) then
                  t = ( xi(i) - xd(1) ) / ( xd(2) - xd(1) )
                  yi(i) = ( 1.0D+00 - t ) * yd(1) + t * yd(2)
                  else if ( xd(nd) <= xi(i) ) then
                  t = ( xi(i) - xd(nd-1) ) / ( xd(nd) - xd(nd-1) )
                  yi(i) = ( 1.0D+00 - t ) * yd(nd-1) + t * yd(nd)
                  else
                  do k = 2, nd
                        if ( xd(k-1) <= xi(i) .and. xi(i) <= xd(k) ) then
                              t = ( xi(i) - xd(k-1) ) / ( xd(k) - xd(k-1) )
                              yi(i) = ( 1.0D+00 - t ) * yd(k-1) + t * yd(k)
                              exit
                        end if
                  end do
                  end if
            end do
            return
      end
      